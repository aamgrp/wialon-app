<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wialon Sensor Plotter</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        input, select, button { margin: 5px; padding: 5px; }
        #chart { width: 100%; height: 400px; }
        .hidden { display: none; }
        #loginForm select { margin: 5px; }
        .date-row { display: flex; align-items: center; margin: 10px 0; }
        .date-row label { margin-right: 10px; }
        .section { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; }
        .transfer-box { display: inline-block; vertical-align: top; margin: 5px; }
        .transfer-box select { width: 150px; height: 150px; }
        .transfer-btns { display: block; text-align: center; margin: 10px 0; }
        .y-axis-targets { display: flex; justify-content: space-around; }
        .y-axis-box { width: 200px; }
        .y-axis-box select { width: 100%; height: 120px; }
        .combined-row { display: flex; justify-content: space-between; align-items: flex-start; }
        .panel { flex: 1; }
        .left-panel { flex: 1; margin-right: 20px; }
        .right-panel { flex: 1; }
    </style>
</head>
<body>
    <h1>AAMG Sensor Visualiser</h1>
    
    <div id="loginForm">
        <label>Server: 
            <select id="serverSelect">
                <option value="https://hst-api.wialon.com">Wialon Hosting (.com)</option>
                <option value="https://hst-api.wialon.eu">Wialon Hosting EU (.eu)</option>
            </select>
        </label><br>
        <label>Username: <input type="text" id="username" required></label><br>
        <label>Password: <input type="password" id="password" required></label><br>
        <button type="submit">Login</button>
    </div>
    
    <div id="combinedSection" class="hidden section combined-row">
        <div class="panel">
            <h3>Units</h3>
            <select id="unitSelect" multiple size="10">
                <option value="">Loading units...</option>
            </select>
            <button id="loadSensors">Load Sensors</button>
        </div>
        <div class="panel">
            <h3>Sensors</h3>
            <div class="transfer-box">
                <select id="availableSensors" multiple size="10">
                    <option value="">No sensors</option>
                </select>
            </div>
        </div>
        <div class="transfer-btns panel">
            <button id="addToY1">&gt;&gt; Y1</button><br>
            <button id="addToY2">&gt;&gt; Y2</button>
        </div>
        <div class="panel">
            <div class="y-axis-box">
                <label>Y-Axis 1 (Left):</label>
                <select id="y1Sensors" multiple size="8"></select>
                <div class="transfer-btns">
                    <button id="removeFromY1">&lt;&lt; Remove</button>
                </div>
            </div>
            <div class="y-axis-box">
                <label>Y-Axis 2 (Right):</label>
                <select id="y2Sensors" multiple size="8"></select>
                <div class="transfer-btns">
                    <button id="removeFromY2">&lt;&lt; Remove</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="date-row hidden" id="dateRow">
        <label>Start Date: <input type="date" id="startDate"></label>
        <label>End Date: <input type="date" id="endDate"></label>
    </div>
    <button id="plotBtn" class="hidden">Plot Data</button>
    
    <div id="chart" class="hidden"></div>
    
    <script>
        let baseUrl = null;
        let session = null;
        let units = [];
        let allSensors = [];  // Flat list of {unitId, sensor}
        let chart = null;

        // Initialize ECharts
        const chartDom = document.getElementById('chart');
        chart = echarts.init(chartDom);

        // Resize chart when container is shown
        function resizeChart() {
            if (chart) {
                chart.resize();
            }
        }

        // Listen for window resize
        window.addEventListener('resize', resizeChart);

        // Parse URL params
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                sid: params.get('sid'),
                user: params.get('user'),
                baseUrl: params.get('baseUrl'),
                authHash: params.get('authHash')
            };
        }

        // Load Wialon SDK dynamically
        async function loadSDK() {
            return new Promise((resolve, reject) => {
                if (window.wialon) {
                    console.log('Wialon SDK already loaded');
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://hst-api.wialon.com/wsdk/script/wialon.js';
                script.onerror = () => reject(new Error('Failed to load Wialon SDK'));
                script.onload = () => {
                    console.log('Wialon SDK loaded successfully');
                    resolve();
                };
                document.head.appendChild(script);
            });
        }

        // Initialize session
        async function initSession(url) {
            baseUrl = url;
            await loadSDK();
            if (!window.wialon) {
                throw new Error('Wialon SDK not available after load');
            }
            session = wialon.core.Session.getInstance();
            session.initSession(baseUrl);
            console.log('Session initialized with baseUrl:', baseUrl);
        }

        // Login callback
        function onLogin(code) {
            if (code) {
                throw new Error('Login failed: ' + wialon.core.Errors.getErrorText(code));
            }
            console.log('Logged in successfully');
            const sess = wialon.core.Session.getInstance();
            sess.loadLibrary('unitSensors'); // Load sensor library
            fetchUnits();
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('combinedSection').classList.remove('hidden');
        }

        // App launcher init
        async function initFromLauncher() {
            const params = getUrlParams();
            if (!params.baseUrl) return false;

            try {
                await initSession(decodeURIComponent(params.baseUrl));
                if (params.authHash) {
                    return new Promise((resolve) => {
                        session.loginAuthHash(params.authHash, '', (code) => {
                            try {
                                onLogin(code);
                                resolve(true);
                            } catch (err) {
                                alert(err.message);
                                resolve(false);
                            }
                        });
                    });
                } else {
                    return false;
                }
            } catch (err) {
                alert('SDK init error: ' + err.message);
                return false;
            }
        }

        // Manual login
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const serverUrl = document.getElementById('serverSelect').value;
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            
            try {
                await initSession(serverUrl);
                return new Promise((resolve) => {
                    session.login(user, pass, '', (code) => {
                        try {
                            onLogin(code);
                            resolve();
                        } catch (err) {
                            alert(err.message);
                            resolve();
                        }
                    });
                });
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });

        // Fetch all units with sensors pre-loaded
        function fetchUnits() {
            const sess = wialon.core.Session.getInstance();
            const flags = wialon.item.Item.dataFlag.base | wialon.item.Unit.dataFlag.sensors;

            sess.updateDataFlags(
                [{ type: 'type', data: 'avl_unit', flags: flags, mode: 0 }],
                (code) => {
                    console.log('Units updateDataFlags callback:', { code });
                    if (code) {
                        console.error('Units load error:', code, wialon.core.Errors.getErrorText(code));
                        alert('Failed to fetch units: ' + wialon.core.Errors.getErrorText(code));
                        return;
                    }
                    units = sess.getItems('avl_unit') || [];
                    const select = document.getElementById('unitSelect');
                    select.innerHTML = '<option value="">Select units</option>';
                    units.forEach(unit => {
                        const option = document.createElement('option');
                        option.value = unit.getId();
                        option.textContent = unit.getName();
                        select.appendChild(option);
                    });
                    console.log('Units loaded:', units.length);
                }
            );
        }

        // Load sensors for selected units
        document.getElementById('loadSensors').addEventListener('click', () => {
            allSensors = [];
            const availSensors = document.getElementById('availableSensors');
            availSensors.innerHTML = '<option value="">Loading...</option>';

            const selectedUnits = Array.from(document.getElementById('unitSelect').selectedOptions).map(opt => parseInt(opt.value));
            if (selectedUnits.length === 0) {
                alert('Select units first');
                return;
            }

            selectedUnits.forEach(unitId => {
                const unit = session.getItem(unitId);
                if (!unit) return;

                const sensObj = unit.getSensors() || {};
                for (var i in sensObj) {
                    const fullSensor = sensObj[i];
                    allSensors.push({
                        unitId: unitId,
                        index: parseInt(i),
                        id: fullSensor.id,
                        name: fullSensor.n,
                        full: fullSensor
                    });
                }
            });

            populateAvailableSensors();

            // Set default dates and show plot button
            const now = new Date();
            const yesterday = new Date(now.getTime() - 86400000);
            document.getElementById('startDate').value = yesterday.toISOString().split('T')[0];
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
            document.getElementById('dateRow').classList.remove('hidden');
            document.getElementById('plotBtn').classList.remove('hidden');
        });

        // Populate available sensors
        function populateAvailableSensors() {
            const availSensors = document.getElementById('availableSensors');
            availSensors.innerHTML = '';
            allSensors.forEach(sensor => {
                const option = document.createElement('option');
                option.value = `${sensor.unitId}_${sensor.index}`;
                option.textContent = `${sensor.name} (Unit: ${sensor.unitId}, Index: ${sensor.index})`;
                availSensors.appendChild(option);
            });
        }

        // Transfer to Y-axes
        document.getElementById('addToY1').addEventListener('click', () => {
            const avail = document.getElementById('availableSensors');
            const y1 = document.getElementById('y1Sensors');
            Array.from(avail.selectedOptions).forEach(opt => y1.appendChild(opt));
        });

        document.getElementById('addToY2').addEventListener('click', () => {
            const avail = document.getElementById('availableSensors');
            const y2 = document.getElementById('y2Sensors');
            Array.from(avail.selectedOptions).forEach(opt => y2.appendChild(opt));
        });

        // Remove from Y1
        document.getElementById('removeFromY1').addEventListener('click', () => {
            const y1 = document.getElementById('y1Sensors');
            const avail = document.getElementById('availableSensors');
            Array.from(y1.selectedOptions).forEach(opt => avail.appendChild(opt));
        });

        // Remove from Y2
        document.getElementById('removeFromY2').addEventListener('click', () => {
            const y2 = document.getElementById('y2Sensors');
            const avail = document.getElementById('availableSensors');
            Array.from(y2.selectedOptions).forEach(opt => avail.appendChild(opt));
        });

        // Plot data
        document.getElementById('plotBtn').addEventListener('click', () => {
            const y1Options = document.getElementById('y1Sensors');
            const y2Options = document.getElementById('y2Sensors');
            const y1Sensors = Array.from(y1Options.options).map(opt => opt.value.split('_').map(Number));
            const y2Sensors = Array.from(y2Options.options).map(opt => opt.value.split('_').map(Number));
            const selectedSensors = [...y1Sensors, ...y2Sensors];  // Flat [unitId, index]
            if (selectedSensors.length === 0) {
                alert('Select sensors for Y-axes');
                return;
            }

            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            if (!startDate || !endDate) {
                alert('Please select start and end dates');
                return;
            }

            // Convert dates to Unix timestamps (start of day)
            const start = Math.floor(new Date(startDate + 'T00:00:00').getTime() / 1000);
            const end = Math.floor(new Date(endDate + 'T23:59:59').getTime() / 1000);

            const loadCount = 100;

            const sess = wialon.core.Session.getInstance();
            const uniqueUnits = [...new Set(selectedSensors.map(s => s[0]))];  // Unique unit IDs

            // Aggregate data from multiple units
            const allMessages = [];
            let loadedUnits = 0;
            uniqueUnits.forEach(unitId => {
                const ml = sess.getMessagesLoader();
                ml.loadInterval(unitId, start, end, 0, 0, loadCount, (code, response) => {
                    if (code !== 0) {
                        console.error('Failed to load messages for unit', unitId);
                        loadedUnits++;
                        if (loadedUnits === uniqueUnits.length) plotData(allMessages, selectedSensors, y1Sensors, y2Sensors, startDate, endDate);
                        return;
                    }
                    const {messages} = response;
                    messages.forEach(msg => msg.unitId = unitId);  // Tag with unit
                    allMessages.push(...messages);
                    loadedUnits++;
                    if (loadedUnits === uniqueUnits.length) {
                        plotData(allMessages, selectedSensors, y1Sensors, y2Sensors, startDate, endDate);
                    }
                });
            });
        });

        // Plot aggregated data
        function plotData(allMessages, selectedSensors, y1Sensors, y2Sensors, startDate, endDate) {
            if (allMessages.length === 0) {
                alert('No messages found in the selected date range');
                return;
            }

            const sess = wialon.core.Session.getInstance();
            const seriesData = {};
            selectedSensors.forEach(([unitId, sId]) => {
                seriesData[`${unitId}_${sId}`] = [];
            });

            allMessages.forEach(msg => {
                if (msg.t) {
                    const time = new Date(msg.t * 1000).getTime();
                    const unit = sess.getItem(msg.unitId);
                    selectedSensors.forEach(([uId, sId]) => {
                        if (uId === msg.unitId) {
                            const sensorInfo = allSensors.find(s => s.unitId === uId && s.index === sId);
                            if (sensorInfo) {
                                const sens = sensorInfo.full;
                                const value = unit.calculateSensorValue(sens, msg);
                                if (value !== undefined && value !== null && value !== -348201.3876) {
                                    seriesData[`${uId}_${sId}`].push([time, value]);
                                }
                            }
                        }
                    });
                }
            });

            // Prepare series
            const y1Series = y1Sensors.map(([uId, sId]) => {
                const sensor = allSensors.find(s => s.unitId === uId && s.index === sId);
                return {
                    name: sensor ? `${sensor.name} (U${uId})` : `Sensor ${sId}`,
                    type: 'line',
                    yAxisIndex: 0,
                    data: seriesData[`${uId}_${sId}`]
                };
            });

            const y2Series = y2Sensors.map(([uId, sId]) => {
                const sensor = allSensors.find(s => s.unitId === uId && s.index === sId);
                return {
                    name: sensor ? `${sensor.name} (U${uId})` : `Sensor ${sId}`,
                    type: 'line',
                    yAxisIndex: 1,
                    data: seriesData[`${uId}_${sId}`]
                };
            });

            const option = {
                title: { text: `Sensor Data Over Time (${startDate} to ${endDate})` },
                tooltip: { trigger: 'axis' },
                legend: { data: [...y1Series.map(s => s.name), ...y2Series.map(s => s.name)] },
                xAxis: { type: 'time' },
                yAxis: [
                    { type: 'value', position: 'left', name: 'Y1' },
                    { type: 'value', position: 'right', name: 'Y2' }
                ],
                series: [...y1Series, ...y2Series]
            };

            chart.setOption(option);
            document.getElementById('chart').classList.remove('hidden');
            resizeChart();  // Resize after unhiding
        }

        // Start the app
        async function initApp() {
            const fromLauncher = await initFromLauncher();
            if (!fromLauncher) {
                document.getElementById('loginForm').classList.remove('hidden');
            }
        }

        initApp();
    </script>
</body>
</html>