<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wialon Sensor Plotter</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        input, select, button { margin: 5px; padding: 5px; }
        #chart { width: 100%; height: 400px; }
        .hidden { display: none; }
        #loginForm select { margin: 5px; }
    </style>
</head>
<body>
    <h1>Wialon Sensor Plotter</h1>
    
    <div id="loginForm">
        <label>Server: 
            <select id="serverSelect">
                <option value="https://hst-api.wialon.com">Wialon Hosting (.com)</option>
                <option value="https://hst-api.wialon.eu">Wialon Hosting EU (.eu)</option>
            </select>
        </label><br>
        <label>Username: <input type="text" id="username" required></label><br>
        <label>Password: <input type="password" id="password" required></label><br>
        <button type="submit">Login</button>
        <p><small>For App Launcher: Ensure "Authorize hash" is enabled in Apps Configurator.</small></p>
    </div>
    
    <div id="unitsSection" class="hidden">
        <label>Select Unit: 
            <select id="unitSelect">
                <option value="">Select a unit</option>
            </select>
        </label>
        <button id="loadSensors">Load Sensors</button>
    </div>
    
    <div id="sensorsSection" class="hidden">
        <label>Sensors: 
            <select id="sensorSelect" multiple size="5">
                <option value="">No sensors</option>
            </select>
        </label><br>
        <button id="plotBtn">Plot Data</button>
    </div>
    
    <div id="chart" class="hidden"></div>
    
    <script>
        let baseUrl = null;
        let session = null;
        let units = [];
        let sensors = [];
        let chart = null;

        // Initialize ECharts
        const chartDom = document.getElementById('chart');
        chart = echarts.init(chartDom);

        // Parse URL params
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                sid: params.get('sid'),
                user: params.get('user'),
                baseUrl: params.get('baseUrl'),
                authHash: params.get('authHash')  // Corrected from 'ah'
            };
        }

        // Load Wialon SDK dynamically
        async function loadSDK(url) {
            return new Promise((resolve, reject) => {
                if (window.wialon) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = url + '/wsdk/script/wialon.js';
                script.onerror = () => reject(new Error('Failed to load SDK'));
                script.onload = () => resolve();
                document.head.appendChild(script);
            });
        }

        // Initialize session
        async function initSession(url) {
            baseUrl = url;
            await loadSDK(baseUrl);
            session = wialon.core.Session.getInstance();
            session.initSession(baseUrl);
        }

        // Login callback
        function onLogin(code) {
            if (code) {
                throw new Error('Login failed: ' + wialon.core.Errors.getErrorText(code));
            }
            console.log('Logged in successfully');
            fetchUnits();
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('unitsSection').classList.remove('hidden');
        }

        // App launcher init (now returns promise)
        async function initFromLauncher() {
            const params = getUrlParams();
            if (!params.baseUrl) return false;

            try {
                await initSession(decodeURIComponent(params.baseUrl));
                if (params.authHash) {
                    // Use authHash for login
                    return new Promise((resolve) => {
                        session.loginAuthHash(params.authHash, '', (code) => {
                            try {
                                onLogin(code);
                                resolve(true);
                            } catch (err) {
                                alert(err.message);
                                resolve(false);
                            }
                        });
                    });
                } else if (params.sid) {
                    // For Active SID: Not directly supported in JS SDK (IP-bound). Show manual login.
                    alert('SID detected, but JS SDK requires "Authorize hash" for client-side apps. Please update Apps Configurator to use "Authorize hash" instead. Falling back to manual login.');
                    return false;
                } else {
                    return false;
                }
            } catch (err) {
                alert('SDK init error: ' + err.message);
                return false;
            }
        }

        // Manual login
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const serverUrl = document.getElementById('serverSelect').value;
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            
            try {
                await initSession(serverUrl);
                return new Promise((resolve) => {
                    session.login(user, pass, '', (code) => {
                        try {
                            onLogin(code);
                            resolve();
                        } catch (err) {
                            alert(err.message);
                            resolve();
                        }
                    });
                });
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });

        // Fetch units
        function fetchUnits() {
            const searchSpec = {
                itemsType: 'avl_unit',
                propName: 'sys_name',
                propValueMask: '*',
                sortType: 'sys_name'
            };
            const dataFlags = wialon.item.Item.dataFlag.base;

            session.searchItems(searchSpec, true, dataFlags, 0, 0, (code, data) => {
                if (code) {
                    alert('Failed to fetch units: ' + wialon.core.Errors.getErrorText(code));
                    return;
                }
                units = data.items || [];
                const select = document.getElementById('unitSelect');
                select.innerHTML = '<option value="">Select a unit</option>';
                units.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit.getId();
                    option.textContent = unit.getName();
                    select.appendChild(option);
                });
            });
        }

        // Load sensors
        document.getElementById('loadSensors').addEventListener('click', () => {
            const unitId = parseInt(document.getElementById('unitSelect').value);
            if (!unitId) return;

            const dataFlags = wialon.item.Unit.dataFlag.base | wialon.item.Unit.dataFlag.sensors;

            console.log('Fetching sensors for unit ID:', unitId);  // Debug log

            session.searchItem(unitId, dataFlags, (code, data) => {
                console.log('Sensors callback fired:', { code, hasData: !!data });  // Debug log
                console.log(data);
                // if (code) {
                //     alert('Failed to fetch unit: ' + wialon.core.Errors.getErrorText(code));
                //     return;
                // }
                const unit = data.item;
                sensors = unit.getSensors() || [];
                console.log('Sensors loaded:', sensors.length);  // Debug log
                const select = document.getElementById('sensorSelect');
                select.innerHTML = '';
                sensors.forEach(sensor => {
                    const option = document.createElement('option');
                    option.value = sensor.getId();
                    option.textContent = `${sensor.getName()} (ID: ${sensor.getId()})`;
                    select.appendChild(option);
                });
                document.getElementById('sensorsSection').classList.remove('hidden');
            });
        });

        // Plot data
        document.getElementById('plotBtn').addEventListener('click', () => {
            const unitId = parseInt(document.getElementById('unitSelect').value);
            const selectedSensors = Array.from(document.getElementById('sensorSelect').selectedOptions).map(opt => parseInt(opt.value));
            if (!unitId || selectedSensors.length === 0) {
                alert('Select unit and sensors');
                return;
            }

            // Last 24 hours
            const now = Math.floor(Date.now() / 1000);
            const timeFrom = now - 86400;
            const timeTo = now;

            const params = {
                itemId: unitId,
                timeFrom,
                timeTo,
                flags: 0xFF00,
                flagsMask: 0xFF00,
                loadCount: 100
            };

            const remote = wialon.core.Remote.getInstance();
            remote.request('messages/load_interval', params, (code, response) => {
                if (code) {
                    alert('Failed to fetch data: ' + wialon.core.Errors.getErrorText(code));
                    return;
                }

                const messages = response.msgs || [];
                const seriesData = {};
                selectedSensors.forEach(sId => {
                    seriesData[sId] = [];
                });

                messages.forEach(msg => {
                    const time = new Date(msg.pos.t).getTime();  // ms for ECharts
                    (msg.sens || []).forEach(sens => {
                        if (selectedSensors.includes(sens.i)) {
                            seriesData[sens.i].push([time, sens.val]);
                        }
                    });
                });

                // Prepare series
                const series = selectedSensors.map(sId => {
                    const sensor = sensors.find(s => s.getId() === sId);
                    return {
                        name: sensor ? sensor.getName() : `Sensor ${sId}`,
                        type: 'line',
                        data: seriesData[sId]
                    };
                });

                const option = {
                    title: { text: 'Sensor Data Over Time' },
                    tooltip: { trigger: 'axis' },
                    xAxis: { type: 'time' },
                    yAxis: { type: 'value' },
                    series: series
                };

                chart.setOption(option);
                document.getElementById('chart').classList.remove('hidden');
            });
        });

        // Start the app
        async function initApp() {
            const fromLauncher = await initFromLauncher();
            if (!fromLauncher) {
                // Show login form for manual access
                document.getElementById('loginForm').classList.remove('hidden');
            }
        }

        initApp();
    </script>
</body>
</html>
