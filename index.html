<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wialon Sensor Plotter</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        input, select, button { margin: 5px; padding: 5px; }
        #chart { width: 100%; height: 400px; }
        .hidden { display: none; }
        #loginForm select { margin: 5px; }
        .date-row { display: flex; align-items: center; margin: 10px 0; }
        .date-row label { margin-right: 10px; }
        .section { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; }
        .transfer-box { display: inline-block; vertical-align: top; margin: 5px; }
        .transfer-box select { width: 150px; height: 150px; }
        .transfer-btns { display: block; text-align: center; margin: 10px 0; }
        .y-axis-targets { display: flex; justify-content: space-around; }
        .y-axis-box { width: 200px; }
        .y-axis-box select { width: 100%; height: 120px; }
    </style>
</head>
<body>
    <h1>Wialon Sensor Plotter</h1>
    
    <div id="loginForm">
        <label>Server: 
            <select id="serverSelect">
                <option value="https://hst-api.wialon.com">Wialon Hosting (.com)</option>
                <option value="https://hst-api.wialon.eu">Wialon Hosting EU (.eu)</option>
            </select>
        </label><br>
        <label>Username: <input type="text" id="username" required></label><br>
        <label>Password: <input type="password" id="password" required></label><br>
        <button type="submit">Login</button>
        <p><small>For App Launcher: Ensure "Authorize hash" is enabled in Apps Configurator.</small></p>
    </div>
    
    <div id="sitesSection" class="hidden">
        <div class="section">
            <h3>Sites</h3>
            <label>Site: 
                <select id="siteSelect" multiple size="5">
                    <option value="">Loading sites...</option>
                </select>
            </label>
            <button id="loadUnits">Load Units</button>
        </div>
    </div>
    
    <div id="unitsSection" class="hidden">
        <div class="section">
            <h3>Units by Site</h3>
            <div id="unitsTransfer"></div>
            <button id="loadSensors">Load Sensors</button>
        </div>
    </div>
    
    <div id="sensorsSection" class="hidden">
        <div class="section">
            <h3>Sensors Assignment</h3>
            <div class="transfer-box">
                <label>Available Sensors:</label>
                <select id="availableSensors" multiple size="10">
                    <option value="">No sensors</option>
                </select>
            </div>
            <div class="transfer-btns">
                <button id="addToY1">&gt;&gt; Y1</button><br>
                <button id="addToY2">&gt;&gt; Y2</button>
            </div>
            <div class="y-axis-targets">
                <div class="y-axis-box">
                    <label>Y-Axis 1 (Left):</label>
                    <select id="y1Sensors" multiple size="8"></select>
                </div>
                <div class="y-axis-box">
                    <label>Y-Axis 2 (Right):</label>
                    <select id="y2Sensors" multiple size="8"></select>
                </div>
            </div>
        </div>
        <div class="date-row">
            <label>Start Date: <input type="date" id="startDate"></label>
            <label>End Date: <input type="date" id="endDate"></label>
        </div>
        <button id="plotBtn">Plot Data</button>
    </div>
    
    <div id="chart" class="hidden"></div>
    
    <script>
        let baseUrl = null;
        let session = null;
        let sites = [];
        let selectedSiteUnits = {};  // {siteId: [unitIds]}
        let allSensors = [];  // Flat list of {unitId, sensor}
        let chart = null;

        // Initialize ECharts
        const chartDom = document.getElementById('chart');
        chart = echarts.init(chartDom);

        // Resize chart when container is shown
        function resizeChart() {
            if (chart) {
                chart.resize();
            }
        }

        // Listen for window resize
        window.addEventListener('resize', resizeChart);

        // Parse URL params
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                sid: params.get('sid'),
                user: params.get('user'),
                baseUrl: params.get('baseUrl'),
                authHash: params.get('authHash')
            };
        }

        // Load Wialon SDK dynamically
        async function loadSDK() {
            return new Promise((resolve, reject) => {
                if (window.wialon) {
                    console.log('Wialon SDK already loaded');
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://hst-api.wialon.com/wsdk/script/wialon.js';
                script.onerror = () => reject(new Error('Failed to load Wialon SDK'));
                script.onload = () => {
                    console.log('Wialon SDK loaded successfully');
                    resolve();
                };
                document.head.appendChild(script);
            });
        }

        // Initialize session
        async function initSession(url) {
            baseUrl = url;
            await loadSDK();
            if (!window.wialon) {
                throw new Error('Wialon SDK not available after load');
            }
            session = wialon.core.Session.getInstance();
            session.initSession(baseUrl);
            console.log('Session initialized with baseUrl:', baseUrl);
        }

        // Login callback
        function onLogin(code) {
            if (code) {
                throw new Error('Login failed: ' + wialon.core.Errors.getErrorText(code));
            }
            console.log('Logged in successfully');
            const sess = wialon.core.Session.getInstance();
            sess.loadLibrary('unitSensors'); // Load sensor library
            sess.loadLibrary('itemResource'); // Load resource library for children
            fetchSites();
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('sitesSection').classList.remove('hidden');
        }

        // App launcher init
        async function initFromLauncher() {
            const params = getUrlParams();
            if (!params.baseUrl) return false;

            try {
                await initSession(decodeURIComponent(params.baseUrl));
                if (params.authHash) {
                    return new Promise((resolve) => {
                        session.loginAuthHash(params.authHash, '', (code) => {
                            try {
                                onLogin(code);
                                resolve(true);
                            } catch (err) {
                                alert(err.message);
                                resolve(false);
                            }
                        });
                    });
                } else {
                    return false;
                }
            } catch (err) {
                alert('SDK init error: ' + err.message);
                return false;
            }
        }

        // Manual login
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const serverUrl = document.getElementById('serverSelect').value;
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            
            try {
                await initSession(serverUrl);
                return new Promise((resolve) => {
                    session.login(user, pass, '', (code) => {
                        try {
                            onLogin(code);
                            resolve();
                        } catch (err) {
                            alert(err.message);
                            resolve();
                        }
                    });
                });
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });

        // Fetch sites (resources)
        function fetchSites() {
            const searchSpec = {
                itemsType: 'avl_resource',
                propName: 'sys_name',
                propValueMask: '*',
                sortType: 'sys_name'
            };
            const dataFlags = wialon.item.Item.dataFlag.base;

            const sess = wialon.core.Session.getInstance();
            sess.searchItems(searchSpec, true, dataFlags, 0, 0, (code, data) => {
                if (code) {
                    alert('Failed to fetch sites: ' + wialon.core.Errors.getErrorText(code));
                    return;
                }
                sites = data.items || [];
                const select = document.getElementById('siteSelect');
                select.innerHTML = '<option value="">Select sites</option>';
                sites.forEach(site => {
                    const option = document.createElement('option');
                    option.value = site.getId();
                    option.textContent = site.getName();
                    select.appendChild(option);
                });
            });
        }

        // Load units for selected sites
        document.getElementById('loadUnits').addEventListener('click', () => {
            const selectedSites = Array.from(document.getElementById('siteSelect').selectedOptions).map(opt => parseInt(opt.value));
            if (selectedSites.length === 0) return;

            selectedSiteUnits = {};
            const unitsContainer = document.getElementById('unitsTransfer');
            unitsContainer.innerHTML = '';

            let loadedSites = 0;
            selectedSites.forEach(siteId => {
                const sess = wialon.core.Session.getInstance();
                const dataFlags = wialon.item.Resource.dataFlag.base | wialon.item.Resource.dataFlag.children;
                sess.searchItem(siteId, dataFlags, (code, data) => {
                    if (code) {
                        console.error('Failed to load site:', code);
                        loadedSites++;
                        if (loadedSites === selectedSites.length) {
                            document.getElementById('unitsSection').classList.remove('hidden');
                        }
                        return;
                    }
                    const site = data.item;
                    const siteUnits = site.getUnits() || [];
                    selectedSiteUnits[siteId] = [];

                    const siteDiv = document.createElement('div');
                    siteDiv.innerHTML = `<h4>${site.getName()}</h4>`;
                    const transferDiv = document.createElement('div');
                    transferDiv.className = 'transfer-box';
                    transferDiv.innerHTML = `
                        <label>Available Units:</label>
                        <select id="availUnits_${siteId}" multiple size="5"></select>
                        <div class="transfer-btns">
                            <button type="button" onclick="moveToSelected('availUnits_${siteId}', 'selUnits_${siteId}')">&gt;</button><br>
                            <button type="button" onclick="moveToAvailable('selUnits_${siteId}', 'availUnits_${siteId}')">&lt;</button>
                        </div>
                        <label>Selected Units:</label>
                        <select id="selUnits_${siteId}" multiple size="5"></select>
                    `;
                    siteDiv.appendChild(transferDiv);
                    unitsContainer.appendChild(siteDiv);

                    const availSelect = document.getElementById(`availUnits_${siteId}`);
                    siteUnits.forEach(u => {
                        const option = document.createElement('option');
                        option.value = u.getId();
                        option.textContent = u.getName();
                        availSelect.appendChild(option);
                    });

                    loadedSites++;
                    if (loadedSites === selectedSites.length) {
                        document.getElementById('unitsSection').classList.remove('hidden');
                    }
                });
            });
        });

        // Helper functions for unit transfer
        function moveToSelected(availId, selId) {
            const avail = document.getElementById(availId);
            const sel = document.getElementById(selId);
            Array.from(avail.selectedOptions).forEach(opt => sel.appendChild(opt));
        }

        function moveToAvailable(selId, availId) {
            const sel = document.getElementById(selId);
            const avail = document.getElementById(availId);
            Array.from(sel.selectedOptions).forEach(opt => avail.appendChild(opt));
        }

        // Load sensors for selected units
        document.getElementById('loadSensors').addEventListener('click', () => {
            allSensors = [];
            const availSensors = document.getElementById('availableSensors');
            availSensors.innerHTML = '<option value="">Loading...</option>';

            // Collect selected units across sites
            const selectedUnits = [];
            Object.keys(selectedSiteUnits).forEach(siteId => {
                const selSelect = document.getElementById(`selUnits_${siteId}`);
                Array.from(selSelect.options).forEach(opt => selectedUnits.push(parseInt(opt.value)));
            });

            if (selectedUnits.length === 0) {
                alert('Select units first');
                return;
            }

            // Fetch sensors for each unit
            let loaded = 0;
            selectedUnits.forEach(unitId => {
                const dataFlags = wialon.item.Unit.dataFlag.base | wialon.item.Unit.dataFlag.sensors;
                const sess = wialon.core.Session.getInstance();
                sess.searchItem(unitId, dataFlags, (code, data) => {
                    if (code) {
                        console.error('Failed to fetch unit sensors:', code);
                        loaded++;
                        if (loaded === selectedUnits.length) {
                            populateAvailableSensors();
                        }
                        return;
                    }
                    const unit = data.item;
                    const sensObj = unit.getSensors() || {};
                    for (var i in sensObj) {
                        const fullSensor = sensObj[i];
                        allSensors.push({
                            unitId: unitId,
                            index: parseInt(i),
                            id: fullSensor.id,
                            name: fullSensor.n,
                            full: fullSensor
                        });
                    }
                    loaded++;
                    if (loaded === selectedUnits.length) {
                        populateAvailableSensors();
                    }
                });
            });

            // Set default dates
            const now = new Date();
            const yesterday = new Date(now.getTime() - 86400000);
            document.getElementById('startDate').value = yesterday.toISOString().split('T')[0];
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
        });

        // Populate available sensors
        function populateAvailableSensors() {
            const availSensors = document.getElementById('availableSensors');
            availSensors.innerHTML = '';
            allSensors.forEach(sensor => {
                const option = document.createElement('option');
                option.value = `${sensor.unitId}_${sensor.index}`;
                option.textContent = `${sensor.name} (Unit: ${sensor.unitId}, Index: ${sensor.index})`;
                availSensors.appendChild(option);
            });
            document.getElementById('sensorsSection').classList.remove('hidden');
        }

        // Transfer to Y-axes
        document.getElementById('addToY1').addEventListener('click', () => {
            const avail = document.getElementById('availableSensors');
            const y1 = document.getElementById('y1Sensors');
            Array.from(avail.selectedOptions).forEach(opt => y1.appendChild(opt));
        });

        document.getElementById('addToY2').addEventListener('click', () => {
            const avail = document.getElementById('availableSensors');
            const y2 = document.getElementById('y2Sensors');
            Array.from(avail.selectedOptions).forEach(opt => y2.appendChild(opt));
        });

        // Plot data
        document.getElementById('plotBtn').addEventListener('click', () => {
            const y1Options = document.getElementById('y1Sensors');
            const y2Options = document.getElementById('y2Sensors');
            const y1Sensors = Array.from(y1Options.options).map(opt => opt.value.split('_').map(Number));
            const y2Sensors = Array.from(y2Options.options).map(opt => opt.value.split('_').map(Number));
            const selectedSensors = [...y1Sensors, ...y2Sensors];  // Flat [unitId, index]
            if (selectedSensors.length === 0) {
                alert('Select sensors for Y-axes');
                return;
            }

            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            if (!startDate || !endDate) {
                alert('Please select start and end dates');
                return;
            }

            // Convert dates to Unix timestamps (start of day)
            const start = Math.floor(new Date(startDate + 'T00:00:00').getTime() / 1000);
            const end = Math.floor(new Date(endDate + 'T23:59:59').getTime() / 1000);

            const loadCount = 100;

            const sess = wialon.core.Session.getInstance();
            const uniqueUnits = [...new Set(selectedSensors.map(s => s[0]))];  // Unique unit IDs

            // Aggregate data from multiple units
            const allMessages = [];
            let loadedUnits = 0;
            uniqueUnits.forEach(unitId => {
                const ml = sess.getMessagesLoader();
                ml.loadInterval(unitId, start, end, 0, 0, loadCount, (code, response) => {
                    if (code !== 0) {
                        console.error('Failed to load messages for unit', unitId);
                        loadedUnits++;
                        if (loadedUnits === uniqueUnits.length) plotData(allMessages, selectedSensors, y1Sensors, y2Sensors, startDate, endDate);
                        return;
                    }
                    const {messages} = response;
                    messages.forEach(msg => msg.unitId = unitId);  // Tag with unit
                    allMessages.push(...messages);
                    loadedUnits++;
                    if (loadedUnits === uniqueUnits.length) {
                        plotData(allMessages, selectedSensors, y1Sensors, y2Sensors, startDate, endDate);
                    }
                });
            });
        });

        // Plot aggregated data
        function plotData(allMessages, selectedSensors, y1Sensors, y2Sensors, startDate, endDate) {
            if (allMessages.length === 0) {
                alert('No messages found in the selected date range');
                return;
            }

            const sess = wialon.core.Session.getInstance();
            const seriesData = {};
            selectedSensors.forEach(([unitId, sId]) => {
                seriesData[`${unitId}_${sId}`] = [];
            });

            allMessages.forEach(msg => {
                if (msg.t) {
                    const time = new Date(msg.t * 1000).getTime();
                    const unit = sess.getItem(msg.unitId);
                    selectedSensors.forEach(([uId, sId]) => {
                        if (uId === msg.unitId) {
                            const sensorInfo = sensors.find(s => s.unitId === uId && s.index === sId);
                            if (sensorInfo) {
                                const sens = sensorInfo.full;
                                const value = unit.calculateSensorValue(sens, msg);
                                if (value !== undefined && value !== null && value !== -348201.3876) {
                                    seriesData[`${uId}_${sId}`].push([time, value]);
                                }
                            }
                        }
                    });
                }
            });

            // Prepare series
            const y1Series = y1Sensors.map(([uId, sId]) => {
                const sensor = sensors.find(s => s.unitId === uId && s.index === sId);
                return {
                    name: sensor ? `${sensor.name} (U${uId})` : `Sensor ${sId}`,
                    type: 'line',
                    yAxisIndex: 0,
                    data: seriesData[`${uId}_${sId}`]
                };
            });

            const y2Series = y2Sensors.map(([uId, sId]) => {
                const sensor = sensors.find(s => s.unitId === uId && s.index === sId);
                return {
                    name: sensor ? `${sensor.name} (U${uId})` : `Sensor ${sId}`,
                    type: 'line',
                    yAxisIndex: 1,
                    data: seriesData[`${uId}_${sId}`]
                };
            });

            const option = {
                title: { text: `Sensor Data Over Time (${startDate} to ${endDate})` },
                tooltip: { trigger: 'axis' },
                legend: { data: [...y1Series.map(s => s.name), ...y2Series.map(s => s.name)] },
                xAxis: { type: 'time' },
                yAxis: [
                    { type: 'value', position: 'left', name: 'Y1' },
                    { type: 'value', position: 'right', name: 'Y2' }
                ],
                series: [...y1Series, ...y2Series]
            };

            chart.setOption(option);
            document.getElementById('chart').classList.remove('hidden');
            resizeChart();  // Resize after unhiding
        }

        // Start the app
        async function initApp() {
            const fromLauncher = await initFromLauncher();
            if (!fromLauncher) {
                document.getElementById('loginForm').classList.remove('hidden');
            }
        }

        initApp();
    </script>
</body>
</html>